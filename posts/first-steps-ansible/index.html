

<!DOCTYPE html>
<html lang="en-us">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
<script type="text/plain" data-type="application/javascript" data-name="googleAnalytics">
  // Hier kommt dein GA-Code (Google Analytics 4 empfohlen!)
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-YNTG7NNKQN', { 'anonymize_ip': true });
</script>

<script type="text/plain" data-type="application/javascript" data-name="googleAnalytics" src="https://www.googletagmanager.com/gtag/js?id=G-YNTG7NNKQN"></script>
<meta charset="UTF-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge"><meta name="robots" content="index, follow"><link rel="author" href="/humans.txt">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" href="/favicon.ico" type="image/x-icon"><link rel="icon" href="/favicon.svg" type="image/svg+xml"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<meta name="msapplication-TileImage" content="/mstile-144x144.png">
<meta name="theme-color" content="#494f5c">
<meta name="msapplication-TileColor" content="#494f5c">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#494f5c"><meta name="author" content="SDN-Warrior"><meta name="description" content="How I Used ChatGPT to Create My First Ansible Playbook">

  <meta itemprop="name" content="From Zero to Automation: How I Used ChatGPT to Create My First Ansible Playbook">
  <meta itemprop="description" content="How I Used ChatGPT to Create My First Ansible Playbook">
  <meta itemprop="datePublished" content="2024-12-17T22:36:18+01:00">
  <meta itemprop="dateModified" content="2024-12-17T22:36:18+01:00">
  <meta itemprop="wordCount" content="2640">
  <meta itemprop="image" content="http://localhost:1313/images/preview.png">
  <meta itemprop="keywords" content="Ansible,Vmware,Chatgpt,Homelab"><meta property="og:url" content="http://localhost:1313/posts/first-steps-ansible/">
  <meta property="og:site_name" content="SDN-Warrior | Daniel Krieger">
  <meta property="og:title" content="From Zero to Automation: How I Used ChatGPT to Create My First Ansible Playbook">
  <meta property="og:description" content="How I Used ChatGPT to Create My First Ansible Playbook">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-12-17T22:36:18+01:00">
    <meta property="article:modified_time" content="2024-12-17T22:36:18+01:00">
    <meta property="article:tag" content="Ansible">
    <meta property="article:tag" content="Vmware">
    <meta property="article:tag" content="Chatgpt">
    <meta property="article:tag" content="Homelab">
    <meta property="og:image" content="http://localhost:1313/images/preview.png">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="http://localhost:1313/images/preview.png">
  <meta name="twitter:title" content="From Zero to Automation: How I Used ChatGPT to Create My First Ansible Playbook">
  <meta name="twitter:description" content="How I Used ChatGPT to Create My First Ansible Playbook">

<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "headline": "From Zero to Automation: How I Used ChatGPT to Create My First Ansible Playbook",
    "name": "From Zero to Automation: How I Used ChatGPT to Create My First Ansible Playbook",
    "description": "How I Used ChatGPT to Create My First Ansible Playbook",
    "keywords": ["ansible", "vmware", "chatgpt", "homelab"],
    "articleBody": "Introduction I recently decided to automate the startup and shutdown of my lab environments—both standard and nested labs. While the idea sounded simple, it quickly turned into an interesting challenge. Having never written an Ansible Playbook before, I turned to ChatGPT for help.\nWhy ChatGPT? Let’s be honest: starting with Ansible can feel overwhelming, especially if you’re new to it. My last experience with something remotely similar was years ago, working with PowerShell scripts or even earlier with .NET 3 (yes, I’m “that old”).\nThe task itself seemed straightforward at first:\nWrite a playbook to power VMs on and off in a controlled manner. Integrate both my standard lab and nested lab (e.g., my VCF setup with its own vCenter). However, the challenge revealed itself quickly:\nControlling VMs via my main vCenter is relatively easy. But what about nested labs where each nested setup has its own vCenter? This is where ChatGPT became a game changer.\nThe Approach Starting from Zero I described my setup and goals to ChatGPT:\nAutomate VM startup/shutdown. Handle dependencies like nested vCenters that control their own VMs. ChatGPT provided a clear starting point, explaining how to structure an Ansible playbook. Step by step, it introduced me to tasks, loops, and the required VMware modules.\nIterating Through Challenges The major challenge was managing nested environments:\nPowering on the parent vCenter first. Waiting until it’s responsive. Then triggering the startup sequence for the nested VMs managed by that vCenter. Through multiple iterations, ChatGPT helped refine the logic.\nNot Always Smooth Sailing To be honest, ChatGPT’s suggestions weren’t always perfect. More than once, I found myself in a dead end. I had to point out repeatedly that the same solution, presented for the third time, simply didn’t work. This is the reality of working with AI: it doesn’t replace expertise, but it certainly accelerates the process.\nWhile ChatGPT couldn’t solve everything on its own, it significantly simplified finding the right solution. Instead of starting from scratch or digging through documentation for hours, I could focus on testing and refining the playbook.\nCurrent Progress: What I Achieved in Two Evenings After a couple of evenings, with a few hours of experimenting and iterating with ChatGPT, I managed to create four modular Ansible playbooks. These playbooks are designed to handle two key scenarios for starting and stopping VMs:\nTwo Playbooks for Environments with vCenter\nThese playbooks are for my standard (non-nested) lab environments, where I can rely on vCenter to manage the VMs. With vCenter in place, controlling VMs is relatively straightforward, as vCenter provides a central interface to handle power states. Two Playbooks for Environments without vCenter\nThese playbooks handle environments where no vCenter is available, such as nested labs or standalone ESXi hosts. In nested labs, the challenge arises because VMs and their dependencies are controlled individually, without the convenience of a central management interface. By separating the logic into modular playbooks, I ensured flexibility and reusability across my different lab setups. Whether I’m dealing with my regular homelab VMs or complex nested environments like my VCF setup, I can now efficiently start and stop VMs with a single command.\nInventory Files: The Backbone of the Setup To make the playbooks flexible and reusable, I created inventory YAML files for each lab. Out of habit, I named them something like vcfvm_vars.yml or vcfesx_vars.yml. These files act as the variable storage for each lab environment.\nThere are two types of inventory files:\nFor Nested VMs:\nIncludes variables specific to nested lab setups, such as nested vCenter credentials, VM names, and their dependencies. For Non-Nested VMs:\nStores details for standard VMs managed directly via the main vCenter.\nNested VCF Example: Controlled Boot and Shutdown In my VCF setup, which is fully nested, the playbook must follow a strict sequence:\nStartup:\nStart the nested ESXi hosts first. Wait for their availability. Then start the nested management VMs, such as NSX Manager, SDDC Manager, and vCenter. Shutdown:\nStop the management VMs first. Once the management layer is powered down, shut down the nested ESXi hosts. This controlled sequence ensures the nested environment behaves predictably.\nInventory File for ESXi Hosts # vcfesx_vars.yml vcenter_hostname: \"vcsa.lab.home\" vcenter_username: \"administrator@vsphere.local\" vcenter_password: \"your_pw\" vcenter_datacenter: \"Homelab\" validate_certs: false vm_names: - \"sfo01-m01-esx01\" - \"sfo01-m01-esx02\" - \"sfo01-m01-esx03\" Inventory File for Nested VMs # vcfvm_vars.yml validate_certs: false esxi_hosts: - \"sfo01-m01-esx01.lab.home\" - \"sfo01-m01-esx02.lab.home\" - \"sfo01-m01-esx03.lab.home\" esxi_username: \"root\" esxi_password: \"your_pw\" esxi_datacenter: \"sfo-m01-dc01\" vm_names: - \"vcfvcsa\" - \"vcfnsx01a\" - \"vcf01\" Power-On Playbook for Non-Nested VMs --- - name: Start specific VMs in vCenter hosts: localhost gather_facts: no collections: - community.vmware tasks: - name: Load variables from file include_vars: \"{{ vars_file }}\" - name: Connect to vCenter and start VMs community.vmware.vmware_guest_powerstate: hostname: \"{{ vcenter_hostname }}\" username: \"{{ vcenter_username }}\" password: \"{{ vcenter_password }}\" validate_certs: \"{{ validate_certs }}\" name: \"{{ item }}\" state: powered-on loop: \"{{ vm_names }}\" register: power_state_result - name: Display power state result debug: msg: \"VM {{ item.item }} wurde erfolgreich gestartet.\" when: item.instance.hw_power_status == \"poweredOn\" loop: \"{{ power_state_result.results }}\" loop_control: label: \"{{ item.item }}\" include_vars: Loads a variable file, such as vcfvm_vars.yml, which makes the playbook modular and reusable.\ncommunity.vmware.vmware_guest_powerstate: Uses the vmware_guest_powerstate module to control the power state of VMs in a vCenter-managed environment.\nThe state: powered-on option ensures VMs are powered on.\nregister: power_state_result: Captures the result of the task execution for each VM, including its power state.\ndebug with when: Checks the power state of each VM and displays a success message if the VM was successfully powered on.\nPower-On Playbook for Nested VMs on Multiple ESXi Hosts --- - name: Power on multiple VMs on multiple ESXi hosts hosts: localhost gather_facts: no collections: - community.vmware tasks: - name: Load variables from file include_vars: \"{{ vars_file }}\" - name: Get VM power status for each VM on each ESXi host community.vmware.vmware_guest_info: hostname: \"{{ item.0 }}\" username: \"{{ esxi_username }}\" password: \"{{ esxi_password }}\" datacenter: \"{{ esxi_datacenter }}\" validate_certs: \"{{ validate_certs }}\" name: \"{{ item.1 }}\" with_nested: - \"{{ esxi_hosts }}\" - \"{{ vm_names }}\" register: vm_info_results ignore_errors: true - name: Filter VMs that are poweredOff set_fact: powered_off_vms: \"{{ vm_info_results.results | selectattr('failed', 'equalto', false) | selectattr('instance.hw_power_status', 'equalto', 'poweredOff') }}\" - name: Power on VMs if they are poweredOff community.vmware.vmware_guest_powerstate: hostname: \"{{ item.item.0 }}\" username: \"{{ esxi_username }}\" password: \"{{ esxi_password }}\" datacenter: \"{{ esxi_datacenter }}\" validate_certs: \"{{ validate_certs }}\" name: \"{{ item.item.1 }}\" state: powered-on loop: \"{{ powered_off_vms }}\" loop_control: label: \"Host: {{ item.item.0 }} | VM: {{ item.item.1 }}\" register: poweron_results - name: Wait for VMs to be powered on community.vmware.vmware_guest_info: hostname: \"{{ item.item.item.0 }}\" username: \"{{ esxi_username }}\" password: \"{{ esxi_password }}\" datacenter: \"{{ esxi_datacenter }}\" validate_certs: \"{{ validate_certs }}\" name: \"{{ item.item.item.1 }}\" loop: \"{{ poweron_results.results }}\" loop_control: label: \"Host: {{ item.item.item.0 }} | VM: {{ item.item.item.1 }}\" register: vm_status until: vm_status.instance.hw_power_status == \"poweredOn\" retries: 20 delay: 15 when: item.failed == false - name: Display power on result debug: msg: \"VM {{ item.item.item.1 }} on Host {{ item.item.item.0 }} has been successfully powered on.\" loop: \"{{ poweron_results.results }}\" loop_control: label: \"Host: {{ item.item.item.0 }} | VM: {{ item.item.item.1 }}\" vmware_guest_info Retrieves the power state of each VM on each ESXi host.\nset_fact Filters out only those VMs that are powered off.\nvmware_guest_powerstate Powers on each VM that is in a “poweredOff” state.\nwait_for with retries Ensures that the VMs are fully powered on before proceeding.\ndebug Displays a confirmation message for each successfully powered-on VM.\nMaster Playbook to orchestrate the two Power-On playbooks in the correct order. I kept your current 60-second pause timer as a placeholder for checking ESXi server readiness but structured everything neatly for clarity. A 60-second pause ensures that the ESXi hosts have enough time to initialize. Why a Pause? Without an active feedback mechanism to confirm the ESXi servers are ready, this static wait acts as a temporary workaround and will replaced later.\n--- - name: Power on Nested ESXi Hosts import_playbook: poweron_vcsa.yml vars: vars_file: \"vcfesx_vars.yml\" # Executes the playbook to power on the nested ESXi hosts. # Variables specific to ESXi servers are loaded from \"vcfesx_vars.yml\". - name: Wait for 60 seconds before powering on nested VMs hosts: localhost gather_facts: no tasks: - name: Pause for 60 seconds pause: seconds: 60 # A static wait time to ensure ESXi hosts are ready. # This will be improved in the future with dynamic checks. - name: Power on Nested Management VMs import_playbook: poweron_esx.yml vars: vars_file: \"vcfvm_vars.yml\" # Executes the playbook to power on nested VMs like NSX Manager, SDDC Manager, and vCenter. # Variables specific to management VMs are loaded from \"vcfvm_vars.yml\". Starting the VMs via the Ansible Master Playbook Starting my VCF nested lab has never been easier. With the Ansible Master Playbook, it’s as simple as running a single command on my Ansible server:\nansible-playbook mp_poweron_vcf.yml Within approximately 5-10 minutes (depending on the overall load on my lab), the entire VCF environment is up and ready to use—without any further manual intervention.\nThe beauty of this setup lies in its flexibility:\nNew labs can be easily added by simply creating a new inventory file and a customized master playbook. The core logic remains untouched, making it a scalable and modular solution for automating additional environments. This approach not only saves time but also ensures consistency when starting up complex nested labs like my VCF setup.\nAnsible Output (click to enlarge)\nThe log output of my Ansible playbook contains failed messages during the task: Get VM power status for each VM on each ESXi host These failures occur because each ESXi host is queried for specific VMs (like vcf01) that may not exist on that particular host. This is both normal and expected behavior.\nWhy? Due to DRS (Distributed Resource Scheduler), I can never be certain which nested ESXi host a particular VM was last running on. By iterating through all ESXi hosts, the playbook ensures that the power status of every VM is eventually retrieved, regardless of where it was previously located.\nShutdown Playbook: Graceful Power-Off of VMs The shutdown process follows the same principles as the power-on playbook but in reverse order. Instead of starting VMs, it ensures a graceful shutdown while verifying their power state. I won’t describe every task in detail, but here’s a quick overview:\nLogic Similar to Power-On:\nVMs are iterated across multiple ESXi hosts. Only VMs that are currently powered on are gracefully shut down. Graceful Shutdown with Validation:\nVMs are shut down using shutdown-guest to trigger the guest OS shutdown process. A retry loop with retries: 20 and delay: 15 ensures that the playbook actively checks until the VMs reach the poweredOff state. Harmless Errors Handled:\nAs with the power-on playbook, the ignore_errors: true directive handles expected failures gracefully (e.g., querying for VMs on ESXi hosts where they are not located). Shutdown Nested VMs - name: Graceful shutdown of multiple VMs on multiple ESXi hosts hosts: localhost gather_facts: no collections: - community.vmware tasks: - name: Load variables from file include_vars: \"{{ vars_file }}\" - name: Get VM power status for each VM on each ESXi host community.vmware.vmware_guest_info: hostname: \"{{ item.0 }}\" username: \"{{ esxi_username }}\" password: \"{{ esxi_password }}\" datacenter: \"{{ esxi_datacenter }}\" validate_certs: \"{{ validate_certs }}\" name: \"{{ item.1 }}\" with_nested: - \"{{ esxi_hosts }}\" - \"{{ vm_names }}\" register: vm_info_results ignore_errors: true - name: Filter VMs that are poweredOn set_fact: powered_on_vms: \"{{ vm_info_results.results | selectattr('failed', 'equalto', false) | selectattr('instance.hw_power_status', 'equalto', 'poweredOn') }}\" - name: Shut down VMs if they are poweredOn community.vmware.vmware_guest_powerstate: hostname: \"{{ item.item.0 }}\" username: \"{{ esxi_username }}\" password: \"{{ esxi_password }}\" datacenter: \"{{ esxi_datacenter }}\" validate_certs: \"{{ validate_certs }}\" name: \"{{ item.item.1 }}\" state: shutdown-guest force: false loop: \"{{ powered_on_vms }}\" loop_control: label: \"Host: {{ item.item.0 }} | VM: {{ item.item.1 }}\" register: shutdown_results - name: Wait for VMs to be powered off community.vmware.vmware_guest_info: hostname: \"{{ item.item.item.0 }}\" username: \"{{ esxi_username }}\" password: \"{{ esxi_password }}\" datacenter: \"{{ esxi_datacenter }}\" validate_certs: \"{{ validate_certs }}\" name: \"{{ item.item.item.1 }}\" loop: \"{{ shutdown_results.results }}\" loop_control: label: \"Host: {{ item.item.item.0 }} | VM: {{ item.item.item.1 }}\" register: vm_status until: vm_status.instance.hw_power_status == \"poweredOff\" retries: 20 delay: 15 when: item.failed == false Shutdown Playbook for Virtual ESXi Servers Using vCenter This playbook is very similar to the nested VM shutdown playbook, but since I can rely on the vCenter, I don’t need to iterate through all ESXi servers. This simplifies the process and improves efficiency.\n--- - name: Graceful shutdown of specific VMs if powered on hosts: localhost gather_facts: no collections: - community.vmware tasks: - name: Load variables from file include_vars: \"{{ vars_file }}\" - name: Get VM information community.vmware.vmware_guest_info: hostname: \"{{ vcenter_hostname }}\" username: \"{{ vcenter_username }}\" password: \"{{ vcenter_password }}\" datacenter: \"{{ vcenter_datacenter }}\" validate_certs: \"{{ validate_certs }}\" name: \"{{ item }}\" loop: \"{{ vm_names }}\" register: vm_info_results - name: Shut down VMs gracefully if powered on community.vmware.vmware_guest_powerstate: hostname: \"{{ vcenter_hostname }}\" username: \"{{ vcenter_username }}\" password: \"{{ vcenter_password }}\" validate_certs: \"{{ validate_certs }}\" name: \"{{ item.item }}\" state: shutdown-guest force: false when: item.instance.hw_power_status == \"poweredOn\" loop: \"{{ vm_info_results.results }}\" register: shutdown_results loop_control: label: \"{{ item.item }}\" - name: Wait for VMs to be powered off community.vmware.vmware_guest_info: hostname: \"{{ vcenter_hostname }}\" username: \"{{ vcenter_username }}\" password: \"{{ vcenter_password }}\" datacenter: \"{{ vcenter_datacenter }}\" validate_certs: \"{{ validate_certs }}\" name: \"{{ item.item }}\" register: vm_status until: vm_status.instance.hw_power_status == \"poweredOff\" retries: 20 delay: 15 loop: \"{{ vm_info_results.results }}\" when: item.instance.hw_power_status == \"poweredOn\" loop_control: label: \"{{ item.item }}\" - name: Display shutdown result debug: msg: \"VM {{ item.item }} ist erfolgreich heruntergefahren oder war bereits ausgeschaltet.\" loop: \"{{ vm_info_results.results }}\" loop_control: label: \"{{ item.item }}\" Use of vCenter:\nThe playbook uses vCenter directly to manage the shutdown process, which avoids manually iterating through all ESXi hosts. Graceful Shutdown:\nThe shutdown-guest option triggers a clean shutdown of the guest operating system running on the virtual ESXi servers. Dynamic Verification:\nThe playbook dynamically filters the powered-on ESXi VMs and waits until their power state is confirmed as poweredOff. Efficiency:\nBy leveraging vCenter and a loop with retries, the process is both clean and efficient.\nMaster Shutdown Playbook To orchestrate the shutdown of the nested VCF lab and its virtual ESXi servers, we’ll create a master playbook similar to the Power-On master playbook. The inventory files remain the same as those used for the Power-On process, ensuring consistency and avoiding duplication.\n- name: Poweroff Nested VMs import_playbook: shutdown_esx.yml vars: vars_file: \"vcfvm_vars.yml\" - name: Poweroff Nested ESXi import_playbook: shutdown_vcsa.yml vars: vars_file: \"vcfesx_vars.yml\" Unlike the Power-On master playbook, the shutdown process does not require a pause or workaround. This is because during the shutdown, we can actively check if the respective VMs have already powered off using a loop. This makes the process cleaner and more efficient.\nAttention\rThe playbooks presented in this article were generated with the help of AI and subsequently adjusted to work in my specific environment. While they function as intended for my use case, I strongly recommend exercising caution and thoroughly testing these playbooks in your own environment before implementing or relying on them.\nAutomation can be powerful, but every infrastructure is unique—always test in a controlled setting first!\nConclusion: Is ChatGPT Useful for Ansible? From my perspective, the answer is both yes and no.\nChatGPT gave me a solid starting point and explained a lot of the foundational concepts, which was extremely helpful as a beginner with Ansible. However, it wasn’t perfect—there were several significant errors in the generated playbooks, and more than once, the AI proposed the same incorrect solution repeatedly.\nDespite these challenges, I still found the process enjoyable. With some manual corrections and adjustments, I was able to create playbooks that worked for my specific environment. Within just a few hours, I achieved a usable result—something that would have taken considerably longer without ChatGPT’s assistance.\nUltimately, while ChatGPT cannot replace expertise or thorough testing, it’s a powerful tool to accelerate development and simplify learning, especially when working with automation tools like Ansible.\n",
    "wordCount" : "2640",
    "inLanguage": "en",
    "image":"http://localhost:1313/images/net.jpg","datePublished": "2024-12-17T22:36:18+01:00",
    "dateModified": "2024-12-17T22:36:18+01:00",
    "author":{
        "@type": "Person",
        "name": "SDN-Warrior",
        "url": "http://localhost:1313/about/"
        },
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "http://localhost:1313/posts/first-steps-ansible/"
    },
    "publisher": {
      "@type": "Organization",
      "name": "SDN-Warrior | Daniel Krieger",
      "description": "",
      "logo": {
        "@type": "ImageObject",
        "url": "http://localhost:1313/favicon.ico"
      }
    }
}
</script><title>From Zero to Automation: How I Used ChatGPT to Create My First Ansible Playbook</title>
<link rel="stylesheet dns-prefetch preconnect preload prefetch" as="style" href="http://localhost:1313/css/style.min.691b64f928c4a491d4338d0d411ad2bbba09852f74d2784509a03c109a91be56.css" integrity="sha256-aRtk+SjEpJHUM40NQRrSu7oJhS900nhFCaA8EJqRvlY=" crossorigin="anonymous">
	<style>.bg-img {background-image: url('/images/net.jpg');}</style></head>
<body id="page">
	<header id="site-header">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="http://localhost:1313/">SDN-Warrior | Daniel Krieger</a>
				</div>
				<nav class="site-nav hide-in-mobile"><a href="http://localhost:1313/posts/">Posts</a><a href="http://localhost:1313/lab-bom/">Lab BOM</a><a href="http://localhost:1313/links/">Links</a><a href="http://localhost:1313/about/">About Me</a></nav>
			</div>
			<div class="hdr-right hdr-icons">
				<button id="img-btn" class="hdr-btn" title=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-image">
      <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
      <circle cx="8.5" cy="8.5" r="1.5"></circle>
      <polyline points="21 15 16 10 5 21"></polyline>
   </svg></button><span class="hdr-links hide-in-mobile"><a href="https://de.linkedin.com/in/daniel-krieger-6476591a9" target="_blank" rel="noopener me" title="Linkedin"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none"
   stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
   <path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path>
   <rect x="2" y="9" width="4" height="12"></rect>
   <circle cx="4" cy="4" r="2"></circle>
</svg></a></span><button id="share-btn" class="hdr-btn" title=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-share-2">
      <circle cx="18" cy="5" r="3"></circle>
      <circle cx="6" cy="12" r="3"></circle>
      <circle cx="18" cy="19" r="3"></circle>
      <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
      <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
   </svg></button>
 
<div id="share-links" class="animated fast">
    
    
    
    
    <ul>
        <li>
            <a href="https://twitter.com/intent/tweet?hashtags=hermit2&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2ffirst-steps-ansible%2f&amp;text=From%20Zero%20to%20Automation%3a%20How%20I%20Used%20ChatGPT%20to%20Create%20My%20First%20Ansible%20Playbook" target="_blank" rel="noopener" aria-label="Share on X"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none"
   stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
   <path class="st0" d="m21.3 21.1 -11.4 -18.2h-7.2l11.4 18.2zm-18.6 0 7.2 -6.6m4.2 -5 7.2 -6.6" />
</svg></a>
        </li>
        <li>
            <a href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2ffirst-steps-ansible%2f" target="_blank" rel="noopener" aria-label="Share on Facebook"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none"
   stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
   <path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path>
</svg></a>
        </li>
        <li>
            <a href="mailto:?subject=From%20Zero%20to%20Automation%3a%20How%20I%20Used%20ChatGPT%20to%20Create%20My%20First%20Ansible%20Playbook&amp;body=http%3a%2f%2flocalhost%3a1313%2fposts%2ffirst-steps-ansible%2f" target="_self" rel="noopener" aria-label="Share on Email"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none"
   stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
   <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
   <polyline points="22,6 12,13 2,6"></polyline>
</svg></a>
        </li>
        <li>
            <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2ffirst-steps-ansible%2f&amp;source=http%3a%2f%2flocalhost%3a1313%2f&amp;title=From%20Zero%20to%20Automation%3a%20How%20I%20Used%20ChatGPT%20to%20Create%20My%20First%20Ansible%20Playbook&amp;summary=From%20Zero%20to%20Automation%3a%20How%20I%20Used%20ChatGPT%20to%20Create%20My%20First%20Ansible%20Playbook%2c%20by%20SDN-Warrior%0a%0aHow%20I%20Used%20ChatGPT%20to%20Create%20My%20First%20Ansible%20Playbook%0a" target="_blank" rel="noopener" aria-label="Share on LinkedIn"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none"
   stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
   <path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path>
   <rect x="2" y="9" width="4" height="12"></rect>
   <circle cx="4" cy="4" r="2"></circle>
</svg></a>
        </li>
        <li>
            <a href="#" onclick="linkShare(&#34;From Zero to Automation: How I Used ChatGPT to Create My First Ansible Playbook&#34;,&#34;http://localhost:1313/posts/first-steps-ansible/&#34;,&#34;From Zero to Automation: How I Used ChatGPT to Create My First Ansible Playbook, by SDN-Warrior\n\nHow I Used ChatGPT to Create My First Ansible Playbook\n&#34;); return false;" target="_self" rel="noopener" aria-label="Copy Link"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-copy">
      <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
      <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
   </svg></a>
        </li>
    </ul>
</div><button id="menu-btn" class="hdr-btn" title=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
   </svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="http://localhost:1313/posts/">Posts</a></li>
			<li><a href="http://localhost:1313/lab-bom/">Lab BOM</a></li>
			<li><a href="http://localhost:1313/links/">Links</a></li>
			<li><a href="http://localhost:1313/about/">About Me</a></li>
		</ul>
	</div>


	<div class="bg-img"></div>
	<main class="site-main section-inner animated fadeIn faster"><article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Dec 17, 2024</span></div>
				<h1>From Zero to Automation: How I Used ChatGPT to Create My First Ansible Playbook</h1>
			</header>
			<div class="post-info"><p>How I Used ChatGPT to Create My First Ansible Playbook</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
   stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-feather">
   <path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path>
   <line x1="16" y1="8" x2="2" y2="22"></line>
   <line x1="17.5" y1="15" x2="9" y2="15"></line>
</svg><a href="/about/" target="_blank">SDN-Warrior</a></p>
<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon">
      <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
      <line x1="7" y1="7" x2="7" y2="7"></line>
   </svg><span class="tag"><a href="http://localhost:1313/tags/ansible">ansible</a></span><span class="tag"><a href="http://localhost:1313/tags/vmware">vmware</a></span><span class="tag"><a href="http://localhost:1313/tags/chatgpt">chatgpt</a></span><span class="tag"><a href="http://localhost:1313/tags/homelab">homelab</a></span></p>
<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text">
      <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
      <polyline points="14 2 14 8 20 8"></polyline>
      <line x1="16" y1="13" x2="8" y2="13"></line>
      <line x1="16" y1="17" x2="8" y2="17"></line>
      <polyline points="10 9 9 9 8 9"></polyline>
   </svg>2640 Words
     // ReadTime
    
    
    
    12 Minutes</p>
<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar">
      <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
      <line x1="16" y1="2" x2="16" y2="6"></line>
      <line x1="8" y1="2" x2="8" y2="6"></line>
      <line x1="3" y1="10" x2="21" y2="10"></line>
   </svg>2024-12-17 22:36 &#43;0100</p></div>
			<hr class="post-end">
			<div class="content">
				<h2 id="introduction">Introduction<a href="#introduction" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>I recently decided to automate the startup and shutdown of my lab environments—both standard and nested labs. While the idea sounded simple, it quickly turned into an interesting challenge. Having never written an Ansible Playbook before, I turned to ChatGPT for help.</p>
<h2 id="why-chatgpt">Why ChatGPT?<a href="#why-chatgpt" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>Let’s be honest: starting with Ansible can feel overwhelming, especially if you&rsquo;re new to it. My last experience with something remotely similar was years ago, working with PowerShell scripts or even earlier with .NET 3 (yes, I’m &ldquo;that old&rdquo;).</p>
<p>The task itself seemed straightforward at first:</p>
<ul>
<li>Write a playbook to power VMs on and off in a controlled manner.</li>
<li>Integrate both my standard lab and nested lab (e.g., my VCF setup with its own vCenter).</li>
</ul>
<p>However, the challenge revealed itself quickly:</p>
<ul>
<li>Controlling VMs via my main vCenter is relatively easy.</li>
<li>But what about nested labs where each nested setup has its own vCenter?</li>
</ul>
<p>This is where ChatGPT became a game changer.</p>
<h2 id="the-approach">The Approach<a href="#the-approach" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<h3 id="starting-from-zero">Starting from Zero<a href="#starting-from-zero" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>I described my setup and goals to ChatGPT:</p>
<p>Automate VM startup/shutdown.
Handle dependencies like nested vCenters that control their own VMs.
ChatGPT provided a clear starting point, explaining how to structure an Ansible playbook. Step by step, it introduced me to tasks, loops, and the required VMware modules.</p>
<h3 id="iterating-through-challenges">Iterating Through Challenges<a href="#iterating-through-challenges" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>The major challenge was managing nested environments:</p>
<p>Powering on the parent vCenter first.
Waiting until it’s responsive.
Then triggering the startup sequence for the nested VMs managed by that vCenter.
Through multiple iterations, ChatGPT helped refine the logic.</p>
<h3 id="not-always-smooth-sailing">Not Always Smooth Sailing<a href="#not-always-smooth-sailing" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>To be honest, ChatGPT’s suggestions weren’t always perfect. More than once, I found myself in a dead end. I had to point out repeatedly that the same solution, presented for the third time, simply didn’t work. This is the reality of working with AI: it doesn’t replace expertise, but it certainly accelerates the process.</p>
<p>While ChatGPT couldn’t solve everything on its own, it significantly simplified finding the right solution. Instead of starting from scratch or digging through documentation for hours, I could focus on testing and refining the playbook.</p>
<h2 id="current-progress-what-i-achieved-in-two-evenings">Current Progress: What I Achieved in Two Evenings<a href="#current-progress-what-i-achieved-in-two-evenings" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>After a couple of evenings, with a few hours of experimenting and iterating with ChatGPT, I managed to create four modular Ansible playbooks. These playbooks are designed to handle two key scenarios for starting and stopping VMs:</p>
<p>Two Playbooks for Environments with vCenter</p>
<p>These playbooks are for my standard (non-nested) lab environments, where I can rely on vCenter to manage the VMs.
With vCenter in place, controlling VMs is relatively straightforward, as vCenter provides a central interface to handle power states.
Two Playbooks for Environments without vCenter</p>
<p>These playbooks handle environments where no vCenter is available, such as nested labs or standalone ESXi hosts.
In nested labs, the challenge arises because VMs and their dependencies are controlled individually, without the convenience of a central management interface.
By separating the logic into modular playbooks, I ensured flexibility and reusability across my different lab setups. Whether I’m dealing with my regular homelab VMs or complex nested environments like my VCF setup, I can now efficiently start and stop VMs with a single command.</p>
<h3 id="inventory-files-the-backbone-of-the-setup">Inventory Files: The Backbone of the Setup<a href="#inventory-files-the-backbone-of-the-setup" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>To make the playbooks flexible and reusable, I created inventory YAML files for each lab. Out of habit, I named them something like vcfvm_vars.yml or vcfesx_vars.yml. These files act as the variable storage for each lab environment.</p>
<p>There are two types of inventory files:</p>
<p>For Nested VMs:</p>
<p>Includes variables specific to nested lab setups, such as nested vCenter credentials, VM names, and their dependencies.
For Non-Nested VMs:</p>
<p>Stores details for standard VMs managed directly via the main vCenter.</p>
<h3 id="nested-vcf-example-controlled-boot-and-shutdown">Nested VCF Example: Controlled Boot and Shutdown<a href="#nested-vcf-example-controlled-boot-and-shutdown" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>In my VCF setup, which is fully nested, the playbook must follow a strict sequence:</p>
<p>Startup:</p>
<p>Start the nested ESXi hosts first.
Wait for their availability.
Then start the nested management VMs, such as NSX Manager, SDDC Manager, and vCenter.
Shutdown:</p>
<p>Stop the management VMs first.
Once the management layer is powered down, shut down the nested ESXi hosts.
This controlled sequence ensures the nested environment behaves predictably.</p>
<h3 id="inventory-file-for-esxi-hosts">Inventory File for ESXi Hosts<a href="#inventory-file-for-esxi-hosts" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl"># vcfesx_vars.yml
</span></span><span class="line"><span class="cl">vcenter_hostname: &#34;vcsa.lab.home&#34;
</span></span><span class="line"><span class="cl">vcenter_username: &#34;administrator@vsphere.local&#34;
</span></span><span class="line"><span class="cl">vcenter_password: &#34;your_pw&#34;
</span></span><span class="line"><span class="cl">vcenter_datacenter: &#34;Homelab&#34;
</span></span><span class="line"><span class="cl">validate_certs: false
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">vm_names:
</span></span><span class="line"><span class="cl">  - &#34;sfo01-m01-esx01&#34;
</span></span><span class="line"><span class="cl">  - &#34;sfo01-m01-esx02&#34;
</span></span><span class="line"><span class="cl">  - &#34;sfo01-m01-esx03&#34;
</span></span></code></pre></div><h3 id="inventory-file-for-nested-vms">Inventory File for Nested VMs<a href="#inventory-file-for-nested-vms" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl"># vcfvm_vars.yml
</span></span><span class="line"><span class="cl">validate_certs: false
</span></span><span class="line"><span class="cl">esxi_hosts:
</span></span><span class="line"><span class="cl">  - &#34;sfo01-m01-esx01.lab.home&#34;
</span></span><span class="line"><span class="cl">  - &#34;sfo01-m01-esx02.lab.home&#34;
</span></span><span class="line"><span class="cl">  - &#34;sfo01-m01-esx03.lab.home&#34;
</span></span><span class="line"><span class="cl">esxi_username: &#34;root&#34;
</span></span><span class="line"><span class="cl">esxi_password: &#34;your_pw&#34;
</span></span><span class="line"><span class="cl">esxi_datacenter: &#34;sfo-m01-dc01&#34;
</span></span><span class="line"><span class="cl">vm_names:
</span></span><span class="line"><span class="cl">  - &#34;vcfvcsa&#34;
</span></span><span class="line"><span class="cl">  - &#34;vcfnsx01a&#34;
</span></span><span class="line"><span class="cl">  - &#34;vcf01&#34;
</span></span></code></pre></div><h3 id="power-on-playbook-for-non-nested-vms">Power-On Playbook for Non-Nested VMs<a href="#power-on-playbook-for-non-nested-vms" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">---
</span></span><span class="line"><span class="cl">- name: Start specific VMs in vCenter
</span></span><span class="line"><span class="cl">  hosts: localhost
</span></span><span class="line"><span class="cl">  gather_facts: no
</span></span><span class="line"><span class="cl">  collections:
</span></span><span class="line"><span class="cl">    - community.vmware
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  tasks:
</span></span><span class="line"><span class="cl">    - name: Load variables from file
</span></span><span class="line"><span class="cl">      include_vars: &#34;{{ vars_file }}&#34;
</span></span><span class="line"><span class="cl">    - name: Connect to vCenter and start VMs
</span></span><span class="line"><span class="cl">      community.vmware.vmware_guest_powerstate:
</span></span><span class="line"><span class="cl">        hostname: &#34;{{ vcenter_hostname }}&#34;
</span></span><span class="line"><span class="cl">        username: &#34;{{ vcenter_username }}&#34;
</span></span><span class="line"><span class="cl">        password: &#34;{{ vcenter_password }}&#34;
</span></span><span class="line"><span class="cl">        validate_certs: &#34;{{ validate_certs }}&#34;
</span></span><span class="line"><span class="cl">        name: &#34;{{ item }}&#34;
</span></span><span class="line"><span class="cl">        state: powered-on
</span></span><span class="line"><span class="cl">      loop: &#34;{{ vm_names }}&#34;
</span></span><span class="line"><span class="cl">      register: power_state_result
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - name: Display power state result
</span></span><span class="line"><span class="cl">      debug:
</span></span><span class="line"><span class="cl">        msg: &#34;VM {{ item.item }} wurde erfolgreich gestartet.&#34;
</span></span><span class="line"><span class="cl">      when: item.instance.hw_power_status == &#34;poweredOn&#34;
</span></span><span class="line"><span class="cl">      loop: &#34;{{ power_state_result.results }}&#34;
</span></span><span class="line"><span class="cl">      loop_control:
</span></span><span class="line"><span class="cl">        label: &#34;{{ item.item }}&#34;
</span></span></code></pre></div><ol>
<li>
<p><em><strong>include_vars:</strong></em> Loads a variable file, such as vcfvm_vars.yml, which makes the playbook modular and reusable.</p>
</li>
<li>
<p><em><strong>community.vmware.vmware_guest_powerstate:</strong></em> Uses the <em><strong>vmware_guest_powerstate</strong></em> module to control the power state of VMs in a vCenter-managed environment.</p>
</li>
<li>
<p><em><strong>The state:</strong></em> powered-on option ensures VMs are powered on.</p>
</li>
<li>
<p><em><strong>register: power_state_result:</strong></em> Captures the result of the task execution for each VM, including its power state.</p>
</li>
<li>
<p><em><strong>debug with when:</strong></em> Checks the power state of each VM and displays a success message if the VM was successfully powered on.</p>
</li>
</ol>
<h3 id="power-on-playbook-for-nested-vms-on-multiple-esxi-hosts">Power-On Playbook for Nested VMs on Multiple ESXi Hosts<a href="#power-on-playbook-for-nested-vms-on-multiple-esxi-hosts" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">---
</span></span><span class="line"><span class="cl">- name: Power on multiple VMs on multiple ESXi hosts
</span></span><span class="line"><span class="cl">  hosts: localhost
</span></span><span class="line"><span class="cl">  gather_facts: no
</span></span><span class="line"><span class="cl">  collections:
</span></span><span class="line"><span class="cl">    - community.vmware
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  tasks:
</span></span><span class="line"><span class="cl">    - name: Load variables from file
</span></span><span class="line"><span class="cl">      include_vars: &#34;{{ vars_file }}&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - name: Get VM power status for each VM on each ESXi host
</span></span><span class="line"><span class="cl">      community.vmware.vmware_guest_info:
</span></span><span class="line"><span class="cl">        hostname: &#34;{{ item.0 }}&#34;
</span></span><span class="line"><span class="cl">        username: &#34;{{ esxi_username }}&#34;
</span></span><span class="line"><span class="cl">        password: &#34;{{ esxi_password }}&#34;
</span></span><span class="line"><span class="cl">        datacenter: &#34;{{ esxi_datacenter }}&#34;
</span></span><span class="line"><span class="cl">        validate_certs: &#34;{{ validate_certs }}&#34;
</span></span><span class="line"><span class="cl">        name: &#34;{{ item.1 }}&#34;
</span></span><span class="line"><span class="cl">      with_nested:
</span></span><span class="line"><span class="cl">        - &#34;{{ esxi_hosts }}&#34;
</span></span><span class="line"><span class="cl">        - &#34;{{ vm_names }}&#34;
</span></span><span class="line"><span class="cl">      register: vm_info_results
</span></span><span class="line"><span class="cl">      ignore_errors: true
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - name: Filter VMs that are poweredOff
</span></span><span class="line"><span class="cl">      set_fact:
</span></span><span class="line"><span class="cl">        powered_off_vms: &#34;{{ vm_info_results.results | selectattr(&#39;failed&#39;, &#39;equalto&#39;, false)
</span></span><span class="line"><span class="cl">                           | selectattr(&#39;instance.hw_power_status&#39;, &#39;equalto&#39;, &#39;poweredOff&#39;) }}&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - name: Power on VMs if they are poweredOff
</span></span><span class="line"><span class="cl">      community.vmware.vmware_guest_powerstate:
</span></span><span class="line"><span class="cl">        hostname: &#34;{{ item.item.0 }}&#34;
</span></span><span class="line"><span class="cl">        username: &#34;{{ esxi_username }}&#34;
</span></span><span class="line"><span class="cl">        password: &#34;{{ esxi_password }}&#34;
</span></span><span class="line"><span class="cl">        datacenter: &#34;{{ esxi_datacenter }}&#34;
</span></span><span class="line"><span class="cl">        validate_certs: &#34;{{ validate_certs }}&#34;
</span></span><span class="line"><span class="cl">        name: &#34;{{ item.item.1 }}&#34;
</span></span><span class="line"><span class="cl">        state: powered-on
</span></span><span class="line"><span class="cl">      loop: &#34;{{ powered_off_vms }}&#34;
</span></span><span class="line"><span class="cl">      loop_control:
</span></span><span class="line"><span class="cl">        label: &#34;Host: {{ item.item.0 }} | VM: {{ item.item.1 }}&#34;
</span></span><span class="line"><span class="cl">      register: poweron_results
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - name: Wait for VMs to be powered on
</span></span><span class="line"><span class="cl">      community.vmware.vmware_guest_info:
</span></span><span class="line"><span class="cl">        hostname: &#34;{{ item.item.item.0 }}&#34;
</span></span><span class="line"><span class="cl">        username: &#34;{{ esxi_username }}&#34;
</span></span><span class="line"><span class="cl">        password: &#34;{{ esxi_password }}&#34;
</span></span><span class="line"><span class="cl">        datacenter: &#34;{{ esxi_datacenter }}&#34;
</span></span><span class="line"><span class="cl">        validate_certs: &#34;{{ validate_certs }}&#34;
</span></span><span class="line"><span class="cl">        name: &#34;{{ item.item.item.1 }}&#34;
</span></span><span class="line"><span class="cl">      loop: &#34;{{ poweron_results.results }}&#34;
</span></span><span class="line"><span class="cl">      loop_control:
</span></span><span class="line"><span class="cl">        label: &#34;Host: {{ item.item.item.0 }} | VM: {{ item.item.item.1 }}&#34;
</span></span><span class="line"><span class="cl">      register: vm_status
</span></span><span class="line"><span class="cl">      until: vm_status.instance.hw_power_status == &#34;poweredOn&#34;
</span></span><span class="line"><span class="cl">      retries: 20
</span></span><span class="line"><span class="cl">      delay: 15
</span></span><span class="line"><span class="cl">      when: item.failed == false
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - name: Display power on result
</span></span><span class="line"><span class="cl">      debug:
</span></span><span class="line"><span class="cl">        msg: &#34;VM {{ item.item.item.1 }} on Host {{ item.item.item.0 }} has been successfully powered on.&#34;
</span></span><span class="line"><span class="cl">      loop: &#34;{{ poweron_results.results }}&#34;
</span></span><span class="line"><span class="cl">      loop_control:
</span></span><span class="line"><span class="cl">        label: &#34;Host: {{ item.item.item.0 }} | VM: {{ item.item.item.1 }}&#34;
</span></span></code></pre></div><ol>
<li>
<p><em><strong>vmware_guest_info</strong></em> Retrieves the power state of each VM on each ESXi host.</p>
</li>
<li>
<p><em><strong>set_fact</strong></em> Filters out only those VMs that are powered off.</p>
</li>
<li>
<p><em><strong>vmware_guest_powerstate</strong></em> Powers on each VM that is in a &ldquo;poweredOff&rdquo; state.</p>
</li>
<li>
<p><em><strong>wait_for with retries</strong></em> Ensures that the VMs are fully powered on before proceeding.</p>
</li>
<li>
<p><em><strong>debug</strong></em> Displays a confirmation message for each successfully powered-on VM.</p>
</li>
</ol>
<h3 id="master-playbook">Master Playbook<a href="#master-playbook" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>to orchestrate the two Power-On playbooks in the correct order. I kept your current 60-second pause timer as a placeholder for checking ESXi server readiness but structured everything neatly for clarity. A 60-second pause ensures that the ESXi hosts have enough time to initialize. Why a Pause? Without an active feedback mechanism to confirm the ESXi servers are ready, this static wait acts as a temporary workaround and will replaced later.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">---
</span></span><span class="line"><span class="cl">- name: Power on Nested ESXi Hosts
</span></span><span class="line"><span class="cl">  import_playbook: poweron_vcsa.yml
</span></span><span class="line"><span class="cl">  vars:
</span></span><span class="line"><span class="cl">    vars_file: &#34;vcfesx_vars.yml&#34;
</span></span><span class="line"><span class="cl">  # Executes the playbook to power on the nested ESXi hosts.
</span></span><span class="line"><span class="cl">  # Variables specific to ESXi servers are loaded from &#34;vcfesx_vars.yml&#34;.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">- name: Wait for 60 seconds before powering on nested VMs
</span></span><span class="line"><span class="cl">  hosts: localhost
</span></span><span class="line"><span class="cl">  gather_facts: no
</span></span><span class="line"><span class="cl">  tasks:
</span></span><span class="line"><span class="cl">    - name: Pause for 60 seconds
</span></span><span class="line"><span class="cl">      pause:
</span></span><span class="line"><span class="cl">        seconds: 60
</span></span><span class="line"><span class="cl">      # A static wait time to ensure ESXi hosts are ready.
</span></span><span class="line"><span class="cl">      # This will be improved in the future with dynamic checks.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">- name: Power on Nested Management VMs
</span></span><span class="line"><span class="cl">  import_playbook: poweron_esx.yml
</span></span><span class="line"><span class="cl">  vars:
</span></span><span class="line"><span class="cl">    vars_file: &#34;vcfvm_vars.yml&#34;
</span></span><span class="line"><span class="cl">  # Executes the playbook to power on nested VMs like NSX Manager, SDDC Manager, and vCenter.
</span></span><span class="line"><span class="cl">  # Variables specific to management VMs are loaded from &#34;vcfvm_vars.yml&#34;.
</span></span></code></pre></div><h3 id="starting-the-vms-via-the-ansible-master-playbook">Starting the VMs via the Ansible Master Playbook<a href="#starting-the-vms-via-the-ansible-master-playbook" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>Starting my VCF nested lab has never been easier. With the Ansible Master Playbook, it’s as simple as running a single command on my Ansible server:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">ansible-playbook mp_poweron_vcf.yml
</span></span></code></pre></div><p>Within approximately 5-10 minutes (depending on the overall load on my lab), the entire VCF environment is up and ready to use—without any further manual intervention.</p>
<p>The beauty of this setup lies in its flexibility:</p>
<p>New labs can be easily added by simply creating a new inventory file and a customized master playbook.
The core logic remains untouched, making it a scalable and modular solution for automating additional environments.
This approach not only saves time but also ensures consistency when starting up complex nested labs like my VCF setup.</p>

<figure><a href="ansible.png"><picture>
          <source srcset="/first-steps-ansible/ansible_hu_78fe14230757b772.webp" type="image/webp">
          <source srcset="/first-steps-ansible/ansible_hu_16a87a118d679d12.jpg" type="image/jpeg">
          <img src="/first-steps-ansible/ansible_hu_78fe14230757b772.webp"alt="Ansible Log"  width="1718"  height="1056" />
        </picture></a><figcaption>
            <p>Ansible Output (click to enlarge)</p>
          </figcaption></figure>
<p>The log output of my Ansible playbook contains failed messages during the task: Get VM power status for each VM on each ESXi host
These failures occur because each ESXi host is queried for specific VMs (like vcf01) that may not exist on that particular host. This is both normal and expected behavior.</p>
<p>Why?
Due to DRS (Distributed Resource Scheduler), I can never be certain which nested ESXi host a particular VM was last running on. By iterating through all ESXi hosts, the playbook ensures that the power status of every VM is eventually retrieved, regardless of where it was previously located.</p>
<h3 id="shutdown-playbook-graceful-power-off-of-vms">Shutdown Playbook: Graceful Power-Off of VMs<a href="#shutdown-playbook-graceful-power-off-of-vms" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>The shutdown process follows the same principles as the power-on playbook but in reverse order. Instead of starting VMs, it ensures a graceful shutdown while verifying their power state. I won&rsquo;t describe every task in detail, but here’s a quick overview:</p>
<p>Logic Similar to Power-On:</p>
<ul>
<li>VMs are iterated across multiple ESXi hosts.</li>
<li>Only VMs that are currently powered on are gracefully shut down.</li>
</ul>
<p>Graceful Shutdown with Validation:</p>
<ul>
<li>VMs are shut down using shutdown-guest to trigger the guest OS shutdown process.</li>
<li>A retry loop with retries: 20 and delay: 15 ensures that the playbook actively checks until the VMs reach the poweredOff state.</li>
</ul>
<p>Harmless Errors Handled:</p>
<ul>
<li>As with the power-on playbook, the ignore_errors: true directive handles expected failures gracefully (e.g., querying for VMs on ESXi hosts where they are not located).</li>
</ul>
<h3 id="shutdown-nested-vms">Shutdown Nested VMs<a href="#shutdown-nested-vms" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">- name: Graceful shutdown of multiple VMs on multiple ESXi hosts
</span></span><span class="line"><span class="cl">  hosts: localhost
</span></span><span class="line"><span class="cl">  gather_facts: no
</span></span><span class="line"><span class="cl">  collections:
</span></span><span class="line"><span class="cl">    - community.vmware
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  tasks:
</span></span><span class="line"><span class="cl">    - name: Load variables from file
</span></span><span class="line"><span class="cl">      include_vars: &#34;{{ vars_file }}&#34;
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">    - name: Get VM power status for each VM on each ESXi host
</span></span><span class="line"><span class="cl">      community.vmware.vmware_guest_info:
</span></span><span class="line"><span class="cl">        hostname: &#34;{{ item.0 }}&#34;
</span></span><span class="line"><span class="cl">        username: &#34;{{ esxi_username }}&#34;
</span></span><span class="line"><span class="cl">        password: &#34;{{ esxi_password }}&#34;
</span></span><span class="line"><span class="cl">        datacenter: &#34;{{ esxi_datacenter }}&#34;
</span></span><span class="line"><span class="cl">        validate_certs: &#34;{{ validate_certs }}&#34;
</span></span><span class="line"><span class="cl">        name: &#34;{{ item.1 }}&#34;
</span></span><span class="line"><span class="cl">      with_nested:
</span></span><span class="line"><span class="cl">        - &#34;{{ esxi_hosts }}&#34;
</span></span><span class="line"><span class="cl">        - &#34;{{ vm_names }}&#34;
</span></span><span class="line"><span class="cl">      register: vm_info_results
</span></span><span class="line"><span class="cl">      ignore_errors: true
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - name: Filter VMs that are poweredOn
</span></span><span class="line"><span class="cl">      set_fact:
</span></span><span class="line"><span class="cl">        powered_on_vms: &#34;{{ vm_info_results.results | selectattr(&#39;failed&#39;, &#39;equalto&#39;, false)
</span></span><span class="line"><span class="cl">                           | selectattr(&#39;instance.hw_power_status&#39;, &#39;equalto&#39;, &#39;poweredOn&#39;) }}&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - name: Shut down VMs if they are poweredOn
</span></span><span class="line"><span class="cl">      community.vmware.vmware_guest_powerstate:
</span></span><span class="line"><span class="cl">        hostname: &#34;{{ item.item.0 }}&#34;
</span></span><span class="line"><span class="cl">        username: &#34;{{ esxi_username }}&#34;
</span></span><span class="line"><span class="cl">        password: &#34;{{ esxi_password }}&#34;
</span></span><span class="line"><span class="cl">        datacenter: &#34;{{ esxi_datacenter }}&#34;
</span></span><span class="line"><span class="cl">        validate_certs: &#34;{{ validate_certs }}&#34;
</span></span><span class="line"><span class="cl">        name: &#34;{{ item.item.1 }}&#34;
</span></span><span class="line"><span class="cl">        state: shutdown-guest
</span></span><span class="line"><span class="cl">        force: false
</span></span><span class="line"><span class="cl">      loop: &#34;{{ powered_on_vms }}&#34;
</span></span><span class="line"><span class="cl">      loop_control:
</span></span><span class="line"><span class="cl">        label: &#34;Host: {{ item.item.0 }} | VM: {{ item.item.1 }}&#34;
</span></span><span class="line"><span class="cl">      register: shutdown_results
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - name: Wait for VMs to be powered off
</span></span><span class="line"><span class="cl">      community.vmware.vmware_guest_info:
</span></span><span class="line"><span class="cl">        hostname: &#34;{{ item.item.item.0 }}&#34;
</span></span><span class="line"><span class="cl">        username: &#34;{{ esxi_username }}&#34;
</span></span><span class="line"><span class="cl">        password: &#34;{{ esxi_password }}&#34;
</span></span><span class="line"><span class="cl">        datacenter: &#34;{{ esxi_datacenter }}&#34;
</span></span><span class="line"><span class="cl">        validate_certs: &#34;{{ validate_certs }}&#34;
</span></span><span class="line"><span class="cl">        name: &#34;{{ item.item.item.1 }}&#34;
</span></span><span class="line"><span class="cl">      loop: &#34;{{ shutdown_results.results }}&#34;
</span></span><span class="line"><span class="cl">      loop_control:
</span></span><span class="line"><span class="cl">        label: &#34;Host: {{ item.item.item.0 }} | VM: {{ item.item.item.1 }}&#34;
</span></span><span class="line"><span class="cl">      register: vm_status
</span></span><span class="line"><span class="cl">      until: vm_status.instance.hw_power_status == &#34;poweredOff&#34;
</span></span><span class="line"><span class="cl">      retries: 20
</span></span><span class="line"><span class="cl">      delay: 15
</span></span><span class="line"><span class="cl">      when: item.failed == false
</span></span></code></pre></div><h3 id="shutdown-playbook-for-virtual-esxi-servers-using-vcenter">Shutdown Playbook for Virtual ESXi Servers Using vCenter<a href="#shutdown-playbook-for-virtual-esxi-servers-using-vcenter" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>This playbook is very similar to the nested VM shutdown playbook, but since I can rely on the vCenter, I don’t need to iterate through all ESXi servers. This simplifies the process and improves efficiency.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">---
</span></span><span class="line"><span class="cl">- name: Graceful shutdown of specific VMs if powered on
</span></span><span class="line"><span class="cl">  hosts: localhost
</span></span><span class="line"><span class="cl">  gather_facts: no
</span></span><span class="line"><span class="cl">  collections:
</span></span><span class="line"><span class="cl">    - community.vmware
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  tasks:
</span></span><span class="line"><span class="cl">    - name: Load variables from file
</span></span><span class="line"><span class="cl">      include_vars: &#34;{{ vars_file }}&#34;
</span></span><span class="line"><span class="cl">    - name: Get VM information
</span></span><span class="line"><span class="cl">      community.vmware.vmware_guest_info:
</span></span><span class="line"><span class="cl">        hostname: &#34;{{ vcenter_hostname }}&#34;
</span></span><span class="line"><span class="cl">        username: &#34;{{ vcenter_username }}&#34;
</span></span><span class="line"><span class="cl">        password: &#34;{{ vcenter_password }}&#34;
</span></span><span class="line"><span class="cl">        datacenter: &#34;{{ vcenter_datacenter }}&#34;
</span></span><span class="line"><span class="cl">        validate_certs: &#34;{{ validate_certs }}&#34;
</span></span><span class="line"><span class="cl">        name: &#34;{{ item }}&#34;
</span></span><span class="line"><span class="cl">      loop: &#34;{{ vm_names }}&#34;
</span></span><span class="line"><span class="cl">      register: vm_info_results
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - name: Shut down VMs gracefully if powered on
</span></span><span class="line"><span class="cl">      community.vmware.vmware_guest_powerstate:
</span></span><span class="line"><span class="cl">        hostname: &#34;{{ vcenter_hostname }}&#34;
</span></span><span class="line"><span class="cl">        username: &#34;{{ vcenter_username }}&#34;
</span></span><span class="line"><span class="cl">        password: &#34;{{ vcenter_password }}&#34;
</span></span><span class="line"><span class="cl">        validate_certs: &#34;{{ validate_certs }}&#34;
</span></span><span class="line"><span class="cl">        name: &#34;{{ item.item }}&#34;
</span></span><span class="line"><span class="cl">        state: shutdown-guest
</span></span><span class="line"><span class="cl">        force: false
</span></span><span class="line"><span class="cl">      when: item.instance.hw_power_status == &#34;poweredOn&#34;
</span></span><span class="line"><span class="cl">      loop: &#34;{{ vm_info_results.results }}&#34;
</span></span><span class="line"><span class="cl">      register: shutdown_results
</span></span><span class="line"><span class="cl">      loop_control:
</span></span><span class="line"><span class="cl">        label: &#34;{{ item.item }}&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - name: Wait for VMs to be powered off
</span></span><span class="line"><span class="cl">      community.vmware.vmware_guest_info:
</span></span><span class="line"><span class="cl">        hostname: &#34;{{ vcenter_hostname }}&#34;
</span></span><span class="line"><span class="cl">        username: &#34;{{ vcenter_username }}&#34;
</span></span><span class="line"><span class="cl">        password: &#34;{{ vcenter_password }}&#34;
</span></span><span class="line"><span class="cl">        datacenter: &#34;{{ vcenter_datacenter }}&#34;
</span></span><span class="line"><span class="cl">        validate_certs: &#34;{{ validate_certs }}&#34;
</span></span><span class="line"><span class="cl">        name: &#34;{{ item.item }}&#34;
</span></span><span class="line"><span class="cl">      register: vm_status
</span></span><span class="line"><span class="cl">      until: vm_status.instance.hw_power_status == &#34;poweredOff&#34;
</span></span><span class="line"><span class="cl">      retries: 20
</span></span><span class="line"><span class="cl">      delay: 15
</span></span><span class="line"><span class="cl">      loop: &#34;{{ vm_info_results.results }}&#34;
</span></span><span class="line"><span class="cl">      when: item.instance.hw_power_status == &#34;poweredOn&#34;
</span></span><span class="line"><span class="cl">      loop_control:
</span></span><span class="line"><span class="cl">        label: &#34;{{ item.item }}&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - name: Display shutdown result
</span></span><span class="line"><span class="cl">      debug:
</span></span><span class="line"><span class="cl">        msg: &#34;VM {{ item.item }} ist erfolgreich heruntergefahren oder war bereits ausgeschaltet.&#34;
</span></span><span class="line"><span class="cl">      loop: &#34;{{ vm_info_results.results }}&#34;
</span></span><span class="line"><span class="cl">      loop_control:
</span></span><span class="line"><span class="cl">        label: &#34;{{ item.item }}&#34;
</span></span></code></pre></div><p>Use of vCenter:</p>
<ul>
<li>
<p>The playbook uses vCenter directly to manage the shutdown process, which avoids manually iterating through all ESXi hosts.
Graceful Shutdown:</p>
</li>
<li>
<p>The shutdown-guest option triggers a clean shutdown of the guest operating system running on the virtual ESXi servers.
Dynamic Verification:</p>
</li>
<li>
<p>The playbook dynamically filters the powered-on ESXi VMs and waits until their power state is confirmed as poweredOff.
Efficiency:</p>
</li>
<li>
<p>By leveraging vCenter and a loop with retries, the process is both clean and efficient.</p>
</li>
</ul>
<h3 id="master-shutdown-playbook">Master Shutdown Playbook<a href="#master-shutdown-playbook" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>To orchestrate the shutdown of the nested VCF lab and its virtual ESXi servers, we’ll create a master playbook similar to the Power-On master playbook. The inventory files remain the same as those used for the Power-On process, ensuring consistency and avoiding duplication.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">- name: Poweroff Nested VMs   
</span></span><span class="line"><span class="cl">  import_playbook: shutdown_esx.yml
</span></span><span class="line"><span class="cl">  vars:
</span></span><span class="line"><span class="cl">    vars_file: &#34;vcfvm_vars.yml&#34;
</span></span><span class="line"><span class="cl">- name: Poweroff Nested ESXi
</span></span><span class="line"><span class="cl">  import_playbook: shutdown_vcsa.yml
</span></span><span class="line"><span class="cl">  vars:
</span></span><span class="line"><span class="cl">    vars_file: &#34;vcfesx_vars.yml&#34;
</span></span></code></pre></div><p>Unlike the Power-On master playbook, the shutdown process does not require a pause or workaround. This is because during the shutdown, we can actively check if the respective VMs have already powered off using a loop. This makes the process cleaner and more efficient.</p>

    <aside class="admonition attention">
        <div class="admonition-title">
            <div class="icon"><svg xmlns="http://www.w3.org/2000/svg" class="feather feather-link" width="24" height="24" viewBox="0 0 24 24"
      fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
      <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
   </svg></div><b>Attention</b>
        </div>
        <div class="admonition-content"><p>The playbooks presented in this article were generated with the help of AI and subsequently adjusted to work in my specific environment. While they function as intended for my use case, I strongly recommend exercising caution and thoroughly testing these playbooks in your own environment before implementing or relying on them.</p>
<p>Automation can be powerful, but every infrastructure is unique—always test in a controlled setting first!</p>
</div>
    </aside>
<h2 id="conclusion-is-chatgpt-useful-for-ansible">Conclusion: Is ChatGPT Useful for Ansible?<a href="#conclusion-is-chatgpt-useful-for-ansible" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>From my perspective, the answer is both yes and no.</p>
<p>ChatGPT gave me a solid starting point and explained a lot of the foundational concepts, which was extremely helpful as a beginner with Ansible. However, it wasn’t perfect—there were several significant errors in the generated playbooks, and more than once, the AI proposed the same incorrect solution repeatedly.</p>
<p>Despite these challenges, I still found the process enjoyable. With some manual corrections and adjustments, I was able to create playbooks that worked for my specific environment. Within just a few hours, I achieved a usable result—something that would have taken considerably longer without ChatGPT&rsquo;s assistance.</p>
<p>Ultimately, while ChatGPT cannot replace expertise or thorough testing, it’s a powerful tool to accelerate development and simplify learning, especially when working with automation tools like Ansible.</p>

			</div>
			
			<div class="post-divider">
  				<img src="/end.png" alt="End graphic" loading="lazy">
			</div>

<div class="related-posts thin">
	<h2>See Also</h2>
	<ul>
	
	<li><a href="/posts/homelab-v5/">Homelab V5</a></li>
	
	<li><a href="/posts/iscsi-tuning/">iSCSI Tuning</a></li>
	
	<li><a href="/posts/mac-learning/">MAC Learning is your friend</a></li>
	
	<li><a href="/posts/labv4/">Homelab V4</a></li>
	
	<li><a href="/posts/nsx-qos/">How to use QoS in NSX</a></li>
	
	</ul>
</div>

		</article>
		<div class="post-nav thin">
			<a class="next-post" href="http://localhost:1313/posts/ipam-automation/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left">
      <line x1="19" y1="12" x2="5" y2="12"></line>
      <polyline points="12 19 5 12 12 5"></polyline>
   </svg>&nbsp;Newer</span><br><span>IPAM Automation with NetBox, Ansible, and Microsoft Windows DNS Server</span>
			</a>
			<a class="prev-post" href="http://localhost:1313/posts/homelab-v5/">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right">
      <line x1="5" y1="12" x2="19" y2="12"></line>
      <polyline points="12 5 19 12 12 19"></polyline>
   </svg></span><br><span>Homelab V5</span>
			</a>
		</div>
		<div id="comments" class="thin"></div>
	</main>

<footer id="site-footer" class="section-inner thin animated fadeIn faster">
	<p>
		&copy; 2025 <a href="http://localhost:1313/">SDN-Warrior</a>
		&#183; COPYRIGHT Daniel Krieger</p>

<script defer src="/klaro/klaro-config.js"></script>

<script defer src="/klaro/klaro.js"></script>
</footer>
<script async src="http://localhost:1313/js/bundle.min.c7c384e4d29d192bbac6811ae4660bb01767194a5bea56baca77e8260f93ea16.js" integrity="sha256-x8OE5NKdGSu6xoEa5GYLsBdnGUpb6la6ynfoJg+T6hY=" crossorigin="anonymous"></script><script async src="http://localhost:1313/js/link-share.min.24409a4f6e5537d70ffc55ec8f9192208d718678cb8638585342423020b37f39.js" integrity="sha256-JECaT25VN9cP/FXsj5GSII1xhnjLhjhYU0JCMCCzfzk=" crossorigin="anonymous"></script>
</body>

</html>
